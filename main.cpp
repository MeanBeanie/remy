#include <iostream>
#include <filesystem>
#include <string>
#include <vector>
#include <fstream>
#include <unistd.h>

using recursive_directory_iterator = std::filesystem::recursive_directory_iterator;

enum InstructionIndex {
	BUILD = 0,
	SRCS,
	FLAGS,
	LIBS,
	PKGS,
	INCLUDE,
	INSTRUCTION_COUNT
};

int main(){
	std::ifstream file(".howtobuild");
	if(!file.is_open()){
		std::cout << "Failed to find .howtobuild" << std::endl;
		return 1;
	}

	std::vector<std::string> lines;
	std::string temp;
	while(std::getline(file, temp)){
		lines.push_back(temp);
	}
	file.close();

	int filesIndex = -1;
	int projectIndex = -1;

	if(lines[0][0] != '['){
		std::cout << ".howtobuild meant to start with \'[\' but started with \'" << lines[0][0] << "\'" << std::endl;
		return 1;
	}
	else{
		if(lines[0][1] == 'F'){
			filesIndex = 0;
		}
		else{
			projectIndex = 0;
		}

		for(int i = 1; i < lines.size(); i++){
			if(lines[i][0] == '['){
				filesIndex = filesIndex == -1 ? i : filesIndex;
				projectIndex = projectIndex == -1 ? i : projectIndex;
				break;
			}
		}
	}

	// -- BUILD HANDLING --

	if(projectIndex == -1){
		std::cout << "No project instructions found" << std::endl;
	}

	// four options, all concatted later
	std::string BUILD_INSTRUCTIONS[INSTRUCTION_COUNT];

	for(int i = projectIndex+1; i < (projectIndex < filesIndex ? filesIndex : lines.size()); i++){
		if(lines[i][0] == '$'){
			std::string ident;
			std::string value;
			bool flip = false;
			for(int j = 1; j < lines[i].size(); j++){
				if(lines[i][j] == ':'){ flip = true; continue; }
				if(lines[i][j] == ' '){ continue; }
				if(!flip){
					ident.push_back(lines[i][j]);
				}
				else{
					if(lines[i][j] == ','){
						value.push_back(' ');
					}
					else{
						value.push_back(lines[i][j]);
					}
				}
			}

			if(ident == "BUILD"){
				BUILD_INSTRUCTIONS[BUILD] = value;
			}
			else if(ident == "FLAGS"){
				BUILD_INSTRUCTIONS[FLAGS] = value;
			}
			else if(ident == "LIBS"){
				BUILD_INSTRUCTIONS[LIBS] = value;
			}
			else if(ident == "SRCS"){
				BUILD_INSTRUCTIONS[SRCS] = value;
			}
			else if(ident == "PKGS"){
				BUILD_INSTRUCTIONS[PKGS] = value;
			}
			else if(ident == "INCLUDE"){
				BUILD_INSTRUCTIONS[INCLUDE] = value;
			}
		}
	}

	std::string name;
	name = lines[projectIndex].substr(1);
	name.pop_back();

	if(BUILD_INSTRUCTIONS[SRCS].empty() || BUILD_INSTRUCTIONS[BUILD].empty()){
		std::cout << "Improper BUILD_INSTRUCTIONS recieved" << std::endl;
		return 1;
	}

	std::string finalBuild = BUILD_INSTRUCTIONS[BUILD] + ' ' + BUILD_INSTRUCTIONS[SRCS] + " -o \"" + name + "\" " + BUILD_INSTRUCTIONS[FLAGS] + ' ' + BUILD_INSTRUCTIONS[INCLUDE] + ' ' + BUILD_INSTRUCTIONS[LIBS];
	if(!BUILD_INSTRUCTIONS[PKGS].empty()){
		finalBuild = finalBuild + " $(pkg-config " + BUILD_INSTRUCTIONS[PKGS] + " --cflags --libs)";
	}

	// -- FILE HANDLING --
	std::vector<std::string> filepaths;

	for(int i = filesIndex+1; i < (filesIndex < projectIndex ? projectIndex : lines.size()); i++){
		filepaths.push_back(lines[i]);
		if(!std::filesystem::exists(lines[i])){
			if(lines[i].back() == '/'){
				std::filesystem::create_directory(lines[i]);
			}
			else{
				std::ofstream temp(lines[i]);
				temp << "[Generated by Remy!]";
				temp.close();
			}
		}
	}

	std::vector<std::filesystem::path> invalidPaths;

	for (const auto& dirEntry : recursive_directory_iterator(std::filesystem::current_path())){
		bool exists = false;
		std::filesystem::path relative = std::filesystem::relative(dirEntry.path());
		for(int i = 0; i < filepaths.size(); i++){
			if(relative.generic_string() == filepaths[i]
				|| relative.generic_string()[0] == '.'
				|| relative.generic_string() == "remy"){
				exists = true;
			}
		}
		
		if(!exists && !dirEntry.is_directory()){
			invalidPaths.push_back(dirEntry.path());
		}
	}

	int size = invalidPaths.size();
	std::string c;
	if(size != 0){
		std::cout << "Found " << size << " paths not listed in .howtobuild:\n";
		for(int i = 0; i < invalidPaths.size(); i++){
			std::cout << invalidPaths[i].generic_string() << '\n';
		}
		std::cout << "Free to delete files?[y/N]: ";
		std::getline(std::cin, c);
		if(c == "y"){
			for(int i = 0; i < invalidPaths.size(); i++){
				std::filesystem::remove(invalidPaths[i]);
			}
			std::cout << "Deleted all " << size << " files" << std::endl; 
		}
		else{
			std::cout << "Free to add files to .howtobuild?[Y/n]: ";
			std::getline(std::cin, c);
			if(c != "n"){
				for(int i = 0; i < invalidPaths.size(); i++){
					std::filesystem::path relative = std::filesystem::relative(invalidPaths[i]);
					lines.insert(lines.begin()+filesIndex+1, relative.generic_string());
				}

				std::ofstream temp("./.howtobuild", std::ios::trunc);
				for(int i = 0; i < lines.size(); i++){
					temp << lines[i] << std::endl;
				}
				temp.close();
			}
		}
	}

	std::cout << "Build? [Y/n]: ";
	c.clear();
	std::getline(std::cin, c);
	if(c != "n"){
		std::cout << "Running \"" << finalBuild << "\"" << std::endl;
		std::system(finalBuild.c_str());
	}

	return 0;
}
